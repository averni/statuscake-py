# coding: utf-8

"""
    StatusCake API

    StatusCake API endpoints to manage monitoring resources.  # Authentication  Documentation on API authentication can be found [here](https://developers.statuscake.com/guides/api/authentication).  # Ratelimiting  Documentation on API ratelimiting can be found [here](https://developers.statuscake.com/guides/api/ratelimiting).  # Errors  Documentation on error handling can be found [here](https://developers.statuscake.com/guides/api/errors).  # Handling Input Parameters  Documentation on input parameters, including how to pass arrays to API endpoints can be found [here](https://developers.statuscake.com/guides/api/parameters). 

    The version of the OpenAPI document: 1.2.0
    Contact: support@statuscake.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from statuscake.models.api_response import APIResponse
from statuscake.models.uptime_test_alerts import UptimeTestAlerts
from statuscake.models.uptime_test_check_rate import UptimeTestCheckRate
from statuscake.models.uptime_test_history import UptimeTestHistory
from statuscake.models.uptime_test_periods import UptimeTestPeriods
from statuscake.models.uptime_test_response import UptimeTestResponse
from statuscake.models.uptime_test_type import UptimeTestType
from statuscake.models.uptime_tests import UptimeTests

from statuscake.api_client import ApiClient, RequestSerialized
from statuscake.api_response import ApiResponse
from statuscake.rest import RESTResponseType


class UptimeApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_uptime_test(
        self,
        name: Annotated[StrictStr, Field(description="Name of the check")],
        test_type: UptimeTestType,
        website_url: Annotated[StrictStr, Field(description="URL or IP address of the server under test")],
        check_rate: UptimeTestCheckRate,
        basic_username: Annotated[Optional[StrictStr], Field(description="Basic authentication username")] = None,
        basic_password: Annotated[Optional[StrictStr], Field(description="Basic authentication password")] = None,
        confirmation: Annotated[Optional[Annotated[int, Field(le=3, strict=True, ge=0)]], Field(description="Number of confirmation servers to confirm downtime before an alert is triggered")] = None,
        contact_groups: Annotated[Optional[List[StrictStr]], Field(description="List of contact group IDs")] = None,
        custom_header: Annotated[Optional[StrictStr], Field(description="JSON object. Represents headers to be sent when making requests")] = None,
        do_not_find: Annotated[Optional[StrictBool], Field(description="Whether to consider the check as down if the content is present within the response")] = None,
        dns_ips: Annotated[Optional[List[StrictStr]], Field(description="List of IP addresses to compare against returned DNS records")] = None,
        dns_server: Annotated[Optional[StrictStr], Field(description="FQDN or IP address of the nameserver to query")] = None,
        enable_ssl_alert: Annotated[Optional[StrictBool], Field(description="Whether to send an alert if the SSL certificate is soon to expire")] = None,
        final_endpoint: Annotated[Optional[StrictStr], Field(description="Specify where the redirect chain should end")] = None,
        find_string: Annotated[Optional[StrictStr], Field(description="String to look for within the response. Considered down if not found")] = None,
        follow_redirects: Annotated[Optional[StrictBool], Field(description="Whether to follow redirects when testing. Disabled by default")] = None,
        host: Annotated[Optional[StrictStr], Field(description="Name of the hosting provider")] = None,
        include_header: Annotated[Optional[StrictBool], Field(description="Include header content in string match search")] = None,
        paused: Annotated[Optional[StrictBool], Field(description="Whether the check should be run")] = None,
        port: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Destination port for TCP checks")] = None,
        post_body: Annotated[Optional[StrictStr], Field(description="JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb")] = None,
        post_raw: Annotated[Optional[StrictStr], Field(description="Raw HTTP POST string to send to the server")] = None,
        regions: Annotated[Optional[List[StrictStr]], Field(description="List of regions on which to run checks. The values required for this parameter can be retrieved from the `GET /v1/uptime-locations` endpoint.")] = None,
        status_codes_csv: Annotated[Optional[StrictStr], Field(description="Comma separated list of status codes that trigger an alert")] = None,
        tags: Annotated[Optional[List[StrictStr]], Field(description="List of tags")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(le=75, strict=True, ge=5)]], Field(description="The number of seconds to wait to receive the first byte")] = None,
        trigger_rate: Annotated[Optional[Annotated[int, Field(le=60, strict=True, ge=0)]], Field(description="The number of minutes to wait before sending an alert")] = None,
        use_jar: Annotated[Optional[StrictBool], Field(description="Whether to enable cookie storage")] = None,
        user_agent: Annotated[Optional[StrictStr], Field(description="Custom user agent string set when testing")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> APIResponse:
        """Create an uptime check

        Creates an uptime check with the given parameters.

        :param name: Name of the check (required)
        :type name: str
        :param test_type: (required)
        :type test_type: UptimeTestType
        :param website_url: URL or IP address of the server under test (required)
        :type website_url: str
        :param check_rate: (required)
        :type check_rate: UptimeTestCheckRate
        :param basic_username: Basic authentication username
        :type basic_username: str
        :param basic_password: Basic authentication password
        :type basic_password: str
        :param confirmation: Number of confirmation servers to confirm downtime before an alert is triggered
        :type confirmation: int
        :param contact_groups: List of contact group IDs
        :type contact_groups: List[str]
        :param custom_header: JSON object. Represents headers to be sent when making requests
        :type custom_header: str
        :param do_not_find: Whether to consider the check as down if the content is present within the response
        :type do_not_find: bool
        :param dns_ips: List of IP addresses to compare against returned DNS records
        :type dns_ips: List[str]
        :param dns_server: FQDN or IP address of the nameserver to query
        :type dns_server: str
        :param enable_ssl_alert: Whether to send an alert if the SSL certificate is soon to expire
        :type enable_ssl_alert: bool
        :param final_endpoint: Specify where the redirect chain should end
        :type final_endpoint: str
        :param find_string: String to look for within the response. Considered down if not found
        :type find_string: str
        :param follow_redirects: Whether to follow redirects when testing. Disabled by default
        :type follow_redirects: bool
        :param host: Name of the hosting provider
        :type host: str
        :param include_header: Include header content in string match search
        :type include_header: bool
        :param paused: Whether the check should be run
        :type paused: bool
        :param port: Destination port for TCP checks
        :type port: int
        :param post_body: JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb
        :type post_body: str
        :param post_raw: Raw HTTP POST string to send to the server
        :type post_raw: str
        :param regions: List of regions on which to run checks. The values required for this parameter can be retrieved from the `GET /v1/uptime-locations` endpoint.
        :type regions: List[str]
        :param status_codes_csv: Comma separated list of status codes that trigger an alert
        :type status_codes_csv: str
        :param tags: List of tags
        :type tags: List[str]
        :param timeout: The number of seconds to wait to receive the first byte
        :type timeout: int
        :param trigger_rate: The number of minutes to wait before sending an alert
        :type trigger_rate: int
        :param use_jar: Whether to enable cookie storage
        :type use_jar: bool
        :param user_agent: Custom user agent string set when testing
        :type user_agent: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_uptime_test_serialize(
            name=name,
            test_type=test_type,
            website_url=website_url,
            check_rate=check_rate,
            basic_username=basic_username,
            basic_password=basic_password,
            confirmation=confirmation,
            contact_groups=contact_groups,
            custom_header=custom_header,
            do_not_find=do_not_find,
            dns_ips=dns_ips,
            dns_server=dns_server,
            enable_ssl_alert=enable_ssl_alert,
            final_endpoint=final_endpoint,
            find_string=find_string,
            follow_redirects=follow_redirects,
            host=host,
            include_header=include_header,
            paused=paused,
            port=port,
            post_body=post_body,
            post_raw=post_raw,
            regions=regions,
            status_codes_csv=status_codes_csv,
            tags=tags,
            timeout=timeout,
            trigger_rate=trigger_rate,
            use_jar=use_jar,
            user_agent=user_agent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "APIResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_uptime_test_with_http_info(
        self,
        name: Annotated[StrictStr, Field(description="Name of the check")],
        test_type: UptimeTestType,
        website_url: Annotated[StrictStr, Field(description="URL or IP address of the server under test")],
        check_rate: UptimeTestCheckRate,
        basic_username: Annotated[Optional[StrictStr], Field(description="Basic authentication username")] = None,
        basic_password: Annotated[Optional[StrictStr], Field(description="Basic authentication password")] = None,
        confirmation: Annotated[Optional[Annotated[int, Field(le=3, strict=True, ge=0)]], Field(description="Number of confirmation servers to confirm downtime before an alert is triggered")] = None,
        contact_groups: Annotated[Optional[List[StrictStr]], Field(description="List of contact group IDs")] = None,
        custom_header: Annotated[Optional[StrictStr], Field(description="JSON object. Represents headers to be sent when making requests")] = None,
        do_not_find: Annotated[Optional[StrictBool], Field(description="Whether to consider the check as down if the content is present within the response")] = None,
        dns_ips: Annotated[Optional[List[StrictStr]], Field(description="List of IP addresses to compare against returned DNS records")] = None,
        dns_server: Annotated[Optional[StrictStr], Field(description="FQDN or IP address of the nameserver to query")] = None,
        enable_ssl_alert: Annotated[Optional[StrictBool], Field(description="Whether to send an alert if the SSL certificate is soon to expire")] = None,
        final_endpoint: Annotated[Optional[StrictStr], Field(description="Specify where the redirect chain should end")] = None,
        find_string: Annotated[Optional[StrictStr], Field(description="String to look for within the response. Considered down if not found")] = None,
        follow_redirects: Annotated[Optional[StrictBool], Field(description="Whether to follow redirects when testing. Disabled by default")] = None,
        host: Annotated[Optional[StrictStr], Field(description="Name of the hosting provider")] = None,
        include_header: Annotated[Optional[StrictBool], Field(description="Include header content in string match search")] = None,
        paused: Annotated[Optional[StrictBool], Field(description="Whether the check should be run")] = None,
        port: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Destination port for TCP checks")] = None,
        post_body: Annotated[Optional[StrictStr], Field(description="JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb")] = None,
        post_raw: Annotated[Optional[StrictStr], Field(description="Raw HTTP POST string to send to the server")] = None,
        regions: Annotated[Optional[List[StrictStr]], Field(description="List of regions on which to run checks. The values required for this parameter can be retrieved from the `GET /v1/uptime-locations` endpoint.")] = None,
        status_codes_csv: Annotated[Optional[StrictStr], Field(description="Comma separated list of status codes that trigger an alert")] = None,
        tags: Annotated[Optional[List[StrictStr]], Field(description="List of tags")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(le=75, strict=True, ge=5)]], Field(description="The number of seconds to wait to receive the first byte")] = None,
        trigger_rate: Annotated[Optional[Annotated[int, Field(le=60, strict=True, ge=0)]], Field(description="The number of minutes to wait before sending an alert")] = None,
        use_jar: Annotated[Optional[StrictBool], Field(description="Whether to enable cookie storage")] = None,
        user_agent: Annotated[Optional[StrictStr], Field(description="Custom user agent string set when testing")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[APIResponse]:
        """Create an uptime check

        Creates an uptime check with the given parameters.

        :param name: Name of the check (required)
        :type name: str
        :param test_type: (required)
        :type test_type: UptimeTestType
        :param website_url: URL or IP address of the server under test (required)
        :type website_url: str
        :param check_rate: (required)
        :type check_rate: UptimeTestCheckRate
        :param basic_username: Basic authentication username
        :type basic_username: str
        :param basic_password: Basic authentication password
        :type basic_password: str
        :param confirmation: Number of confirmation servers to confirm downtime before an alert is triggered
        :type confirmation: int
        :param contact_groups: List of contact group IDs
        :type contact_groups: List[str]
        :param custom_header: JSON object. Represents headers to be sent when making requests
        :type custom_header: str
        :param do_not_find: Whether to consider the check as down if the content is present within the response
        :type do_not_find: bool
        :param dns_ips: List of IP addresses to compare against returned DNS records
        :type dns_ips: List[str]
        :param dns_server: FQDN or IP address of the nameserver to query
        :type dns_server: str
        :param enable_ssl_alert: Whether to send an alert if the SSL certificate is soon to expire
        :type enable_ssl_alert: bool
        :param final_endpoint: Specify where the redirect chain should end
        :type final_endpoint: str
        :param find_string: String to look for within the response. Considered down if not found
        :type find_string: str
        :param follow_redirects: Whether to follow redirects when testing. Disabled by default
        :type follow_redirects: bool
        :param host: Name of the hosting provider
        :type host: str
        :param include_header: Include header content in string match search
        :type include_header: bool
        :param paused: Whether the check should be run
        :type paused: bool
        :param port: Destination port for TCP checks
        :type port: int
        :param post_body: JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb
        :type post_body: str
        :param post_raw: Raw HTTP POST string to send to the server
        :type post_raw: str
        :param regions: List of regions on which to run checks. The values required for this parameter can be retrieved from the `GET /v1/uptime-locations` endpoint.
        :type regions: List[str]
        :param status_codes_csv: Comma separated list of status codes that trigger an alert
        :type status_codes_csv: str
        :param tags: List of tags
        :type tags: List[str]
        :param timeout: The number of seconds to wait to receive the first byte
        :type timeout: int
        :param trigger_rate: The number of minutes to wait before sending an alert
        :type trigger_rate: int
        :param use_jar: Whether to enable cookie storage
        :type use_jar: bool
        :param user_agent: Custom user agent string set when testing
        :type user_agent: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_uptime_test_serialize(
            name=name,
            test_type=test_type,
            website_url=website_url,
            check_rate=check_rate,
            basic_username=basic_username,
            basic_password=basic_password,
            confirmation=confirmation,
            contact_groups=contact_groups,
            custom_header=custom_header,
            do_not_find=do_not_find,
            dns_ips=dns_ips,
            dns_server=dns_server,
            enable_ssl_alert=enable_ssl_alert,
            final_endpoint=final_endpoint,
            find_string=find_string,
            follow_redirects=follow_redirects,
            host=host,
            include_header=include_header,
            paused=paused,
            port=port,
            post_body=post_body,
            post_raw=post_raw,
            regions=regions,
            status_codes_csv=status_codes_csv,
            tags=tags,
            timeout=timeout,
            trigger_rate=trigger_rate,
            use_jar=use_jar,
            user_agent=user_agent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "APIResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_uptime_test_without_preload_content(
        self,
        name: Annotated[StrictStr, Field(description="Name of the check")],
        test_type: UptimeTestType,
        website_url: Annotated[StrictStr, Field(description="URL or IP address of the server under test")],
        check_rate: UptimeTestCheckRate,
        basic_username: Annotated[Optional[StrictStr], Field(description="Basic authentication username")] = None,
        basic_password: Annotated[Optional[StrictStr], Field(description="Basic authentication password")] = None,
        confirmation: Annotated[Optional[Annotated[int, Field(le=3, strict=True, ge=0)]], Field(description="Number of confirmation servers to confirm downtime before an alert is triggered")] = None,
        contact_groups: Annotated[Optional[List[StrictStr]], Field(description="List of contact group IDs")] = None,
        custom_header: Annotated[Optional[StrictStr], Field(description="JSON object. Represents headers to be sent when making requests")] = None,
        do_not_find: Annotated[Optional[StrictBool], Field(description="Whether to consider the check as down if the content is present within the response")] = None,
        dns_ips: Annotated[Optional[List[StrictStr]], Field(description="List of IP addresses to compare against returned DNS records")] = None,
        dns_server: Annotated[Optional[StrictStr], Field(description="FQDN or IP address of the nameserver to query")] = None,
        enable_ssl_alert: Annotated[Optional[StrictBool], Field(description="Whether to send an alert if the SSL certificate is soon to expire")] = None,
        final_endpoint: Annotated[Optional[StrictStr], Field(description="Specify where the redirect chain should end")] = None,
        find_string: Annotated[Optional[StrictStr], Field(description="String to look for within the response. Considered down if not found")] = None,
        follow_redirects: Annotated[Optional[StrictBool], Field(description="Whether to follow redirects when testing. Disabled by default")] = None,
        host: Annotated[Optional[StrictStr], Field(description="Name of the hosting provider")] = None,
        include_header: Annotated[Optional[StrictBool], Field(description="Include header content in string match search")] = None,
        paused: Annotated[Optional[StrictBool], Field(description="Whether the check should be run")] = None,
        port: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Destination port for TCP checks")] = None,
        post_body: Annotated[Optional[StrictStr], Field(description="JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb")] = None,
        post_raw: Annotated[Optional[StrictStr], Field(description="Raw HTTP POST string to send to the server")] = None,
        regions: Annotated[Optional[List[StrictStr]], Field(description="List of regions on which to run checks. The values required for this parameter can be retrieved from the `GET /v1/uptime-locations` endpoint.")] = None,
        status_codes_csv: Annotated[Optional[StrictStr], Field(description="Comma separated list of status codes that trigger an alert")] = None,
        tags: Annotated[Optional[List[StrictStr]], Field(description="List of tags")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(le=75, strict=True, ge=5)]], Field(description="The number of seconds to wait to receive the first byte")] = None,
        trigger_rate: Annotated[Optional[Annotated[int, Field(le=60, strict=True, ge=0)]], Field(description="The number of minutes to wait before sending an alert")] = None,
        use_jar: Annotated[Optional[StrictBool], Field(description="Whether to enable cookie storage")] = None,
        user_agent: Annotated[Optional[StrictStr], Field(description="Custom user agent string set when testing")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create an uptime check

        Creates an uptime check with the given parameters.

        :param name: Name of the check (required)
        :type name: str
        :param test_type: (required)
        :type test_type: UptimeTestType
        :param website_url: URL or IP address of the server under test (required)
        :type website_url: str
        :param check_rate: (required)
        :type check_rate: UptimeTestCheckRate
        :param basic_username: Basic authentication username
        :type basic_username: str
        :param basic_password: Basic authentication password
        :type basic_password: str
        :param confirmation: Number of confirmation servers to confirm downtime before an alert is triggered
        :type confirmation: int
        :param contact_groups: List of contact group IDs
        :type contact_groups: List[str]
        :param custom_header: JSON object. Represents headers to be sent when making requests
        :type custom_header: str
        :param do_not_find: Whether to consider the check as down if the content is present within the response
        :type do_not_find: bool
        :param dns_ips: List of IP addresses to compare against returned DNS records
        :type dns_ips: List[str]
        :param dns_server: FQDN or IP address of the nameserver to query
        :type dns_server: str
        :param enable_ssl_alert: Whether to send an alert if the SSL certificate is soon to expire
        :type enable_ssl_alert: bool
        :param final_endpoint: Specify where the redirect chain should end
        :type final_endpoint: str
        :param find_string: String to look for within the response. Considered down if not found
        :type find_string: str
        :param follow_redirects: Whether to follow redirects when testing. Disabled by default
        :type follow_redirects: bool
        :param host: Name of the hosting provider
        :type host: str
        :param include_header: Include header content in string match search
        :type include_header: bool
        :param paused: Whether the check should be run
        :type paused: bool
        :param port: Destination port for TCP checks
        :type port: int
        :param post_body: JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb
        :type post_body: str
        :param post_raw: Raw HTTP POST string to send to the server
        :type post_raw: str
        :param regions: List of regions on which to run checks. The values required for this parameter can be retrieved from the `GET /v1/uptime-locations` endpoint.
        :type regions: List[str]
        :param status_codes_csv: Comma separated list of status codes that trigger an alert
        :type status_codes_csv: str
        :param tags: List of tags
        :type tags: List[str]
        :param timeout: The number of seconds to wait to receive the first byte
        :type timeout: int
        :param trigger_rate: The number of minutes to wait before sending an alert
        :type trigger_rate: int
        :param use_jar: Whether to enable cookie storage
        :type use_jar: bool
        :param user_agent: Custom user agent string set when testing
        :type user_agent: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_uptime_test_serialize(
            name=name,
            test_type=test_type,
            website_url=website_url,
            check_rate=check_rate,
            basic_username=basic_username,
            basic_password=basic_password,
            confirmation=confirmation,
            contact_groups=contact_groups,
            custom_header=custom_header,
            do_not_find=do_not_find,
            dns_ips=dns_ips,
            dns_server=dns_server,
            enable_ssl_alert=enable_ssl_alert,
            final_endpoint=final_endpoint,
            find_string=find_string,
            follow_redirects=follow_redirects,
            host=host,
            include_header=include_header,
            paused=paused,
            port=port,
            post_body=post_body,
            post_raw=post_raw,
            regions=regions,
            status_codes_csv=status_codes_csv,
            tags=tags,
            timeout=timeout,
            trigger_rate=trigger_rate,
            use_jar=use_jar,
            user_agent=user_agent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "APIResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_uptime_test_serialize(
        self,
        name,
        test_type,
        website_url,
        check_rate,
        basic_username,
        basic_password,
        confirmation,
        contact_groups,
        custom_header,
        do_not_find,
        dns_ips,
        dns_server,
        enable_ssl_alert,
        final_endpoint,
        find_string,
        follow_redirects,
        host,
        include_header,
        paused,
        port,
        post_body,
        post_raw,
        regions,
        status_codes_csv,
        tags,
        timeout,
        trigger_rate,
        use_jar,
        user_agent,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'contact_groups': 'csv',
            'dns_ips': 'csv',
            'regions': 'csv',
            'tags': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if name is not None:
            _form_params.append(('name', name))
        if test_type is not None:
            _form_params.append(('test_type', test_type))
        if website_url is not None:
            _form_params.append(('website_url', website_url))
        if check_rate is not None:
            _form_params.append(('check_rate', check_rate))
        if basic_username is not None:
            _form_params.append(('basic_username', basic_username))
        if basic_password is not None:
            _form_params.append(('basic_password', basic_password))
        if confirmation is not None:
            _form_params.append(('confirmation', confirmation))
        if contact_groups is not None:
            _form_params.append(('contact_groups', contact_groups))
        if custom_header is not None:
            _form_params.append(('custom_header', custom_header))
        if do_not_find is not None:
            _form_params.append(('do_not_find', do_not_find))
        if dns_ips is not None:
            _form_params.append(('dns_ips', dns_ips))
        if dns_server is not None:
            _form_params.append(('dns_server', dns_server))
        if enable_ssl_alert is not None:
            _form_params.append(('enable_ssl_alert', enable_ssl_alert))
        if final_endpoint is not None:
            _form_params.append(('final_endpoint', final_endpoint))
        if find_string is not None:
            _form_params.append(('find_string', find_string))
        if follow_redirects is not None:
            _form_params.append(('follow_redirects', follow_redirects))
        if host is not None:
            _form_params.append(('host', host))
        if include_header is not None:
            _form_params.append(('include_header', include_header))
        if paused is not None:
            _form_params.append(('paused', paused))
        if port is not None:
            _form_params.append(('port', port))
        if post_body is not None:
            _form_params.append(('post_body', post_body))
        if post_raw is not None:
            _form_params.append(('post_raw', post_raw))
        if regions is not None:
            _form_params.append(('regions', regions))
        if status_codes_csv is not None:
            _form_params.append(('status_codes_csv', status_codes_csv))
        if tags is not None:
            _form_params.append(('tags', tags))
        if timeout is not None:
            _form_params.append(('timeout', timeout))
        if trigger_rate is not None:
            _form_params.append(('trigger_rate', trigger_rate))
        if use_jar is not None:
            _form_params.append(('use_jar', use_jar))
        if user_agent is not None:
            _form_params.append(('user_agent', user_agent))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/uptime',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_uptime_test(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete an uptime check

        Deletes an uptime check with the given id.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_uptime_test_serialize(
            test_id=test_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_uptime_test_with_http_info(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete an uptime check

        Deletes an uptime check with the given id.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_uptime_test_serialize(
            test_id=test_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_uptime_test_without_preload_content(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete an uptime check

        Deletes an uptime check with the given id.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_uptime_test_serialize(
            test_id=test_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_uptime_test_serialize(
        self,
        test_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if test_id is not None:
            _path_params['test_id'] = test_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/uptime/{test_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_uptime_test(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UptimeTestResponse:
        """Retrieve an uptime check

        Returns an uptime check with the given id.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_uptime_test_serialize(
            test_id=test_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTestResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_uptime_test_with_http_info(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UptimeTestResponse]:
        """Retrieve an uptime check

        Returns an uptime check with the given id.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_uptime_test_serialize(
            test_id=test_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTestResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_uptime_test_without_preload_content(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve an uptime check

        Returns an uptime check with the given id.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_uptime_test_serialize(
            test_id=test_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTestResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_uptime_test_serialize(
        self,
        test_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if test_id is not None:
            _path_params['test_id'] = test_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/uptime/{test_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_uptime_test_alerts(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of uptime alerts to return per page")] = None,
        before: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only alerts triggered before this UNIX timestamp will be returned")] = None,
        after: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only alerts triggered after this UNIX timestamp will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UptimeTestAlerts:
        """Get all uptime check alerts

        Returns a list of uptime check alerts for a given id.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param limit: The number of uptime alerts to return per page
        :type limit: int
        :param before: Only alerts triggered before this UNIX timestamp will be returned
        :type before: int
        :param after: Only alerts triggered after this UNIX timestamp will be returned
        :type after: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_uptime_test_alerts_serialize(
            test_id=test_id,
            limit=limit,
            before=before,
            after=after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTestAlerts",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_uptime_test_alerts_with_http_info(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of uptime alerts to return per page")] = None,
        before: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only alerts triggered before this UNIX timestamp will be returned")] = None,
        after: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only alerts triggered after this UNIX timestamp will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UptimeTestAlerts]:
        """Get all uptime check alerts

        Returns a list of uptime check alerts for a given id.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param limit: The number of uptime alerts to return per page
        :type limit: int
        :param before: Only alerts triggered before this UNIX timestamp will be returned
        :type before: int
        :param after: Only alerts triggered after this UNIX timestamp will be returned
        :type after: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_uptime_test_alerts_serialize(
            test_id=test_id,
            limit=limit,
            before=before,
            after=after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTestAlerts",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_uptime_test_alerts_without_preload_content(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of uptime alerts to return per page")] = None,
        before: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only alerts triggered before this UNIX timestamp will be returned")] = None,
        after: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only alerts triggered after this UNIX timestamp will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all uptime check alerts

        Returns a list of uptime check alerts for a given id.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param limit: The number of uptime alerts to return per page
        :type limit: int
        :param before: Only alerts triggered before this UNIX timestamp will be returned
        :type before: int
        :param after: Only alerts triggered after this UNIX timestamp will be returned
        :type after: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_uptime_test_alerts_serialize(
            test_id=test_id,
            limit=limit,
            before=before,
            after=after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTestAlerts",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_uptime_test_alerts_serialize(
        self,
        test_id,
        limit,
        before,
        after,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if test_id is not None:
            _path_params['test_id'] = test_id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/uptime/{test_id}/alerts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_uptime_test_history(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of results to return per page")] = None,
        before: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only results created before this UNIX timestamp will be returned")] = None,
        after: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only results created after this UNIX timestamp will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UptimeTestHistory:
        """Get all uptime check history

        Returns a list of uptime check history results for a given id, detailing the runs performed on the StatusCake testing infrastruture.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param limit: The number of results to return per page
        :type limit: int
        :param before: Only results created before this UNIX timestamp will be returned
        :type before: int
        :param after: Only results created after this UNIX timestamp will be returned
        :type after: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_uptime_test_history_serialize(
            test_id=test_id,
            limit=limit,
            before=before,
            after=after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTestHistory",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_uptime_test_history_with_http_info(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of results to return per page")] = None,
        before: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only results created before this UNIX timestamp will be returned")] = None,
        after: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only results created after this UNIX timestamp will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UptimeTestHistory]:
        """Get all uptime check history

        Returns a list of uptime check history results for a given id, detailing the runs performed on the StatusCake testing infrastruture.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param limit: The number of results to return per page
        :type limit: int
        :param before: Only results created before this UNIX timestamp will be returned
        :type before: int
        :param after: Only results created after this UNIX timestamp will be returned
        :type after: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_uptime_test_history_serialize(
            test_id=test_id,
            limit=limit,
            before=before,
            after=after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTestHistory",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_uptime_test_history_without_preload_content(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of results to return per page")] = None,
        before: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only results created before this UNIX timestamp will be returned")] = None,
        after: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only results created after this UNIX timestamp will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all uptime check history

        Returns a list of uptime check history results for a given id, detailing the runs performed on the StatusCake testing infrastruture.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param limit: The number of results to return per page
        :type limit: int
        :param before: Only results created before this UNIX timestamp will be returned
        :type before: int
        :param after: Only results created after this UNIX timestamp will be returned
        :type after: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_uptime_test_history_serialize(
            test_id=test_id,
            limit=limit,
            before=before,
            after=after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTestHistory",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_uptime_test_history_serialize(
        self,
        test_id,
        limit,
        before,
        after,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if test_id is not None:
            _path_params['test_id'] = test_id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/uptime/{test_id}/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_uptime_test_periods(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of uptime check periods to return per page")] = None,
        before: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only check periods created before this UNIX timestamp will be returned")] = None,
        after: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only check periods created after this UNIX timestamp will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UptimeTestPeriods:
        """Get all uptime check periods

        Returns a list of uptime check periods for a given id, detailing the creation time of the period, when it ended and the duration.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param limit: The number of uptime check periods to return per page
        :type limit: int
        :param before: Only check periods created before this UNIX timestamp will be returned
        :type before: int
        :param after: Only check periods created after this UNIX timestamp will be returned
        :type after: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_uptime_test_periods_serialize(
            test_id=test_id,
            limit=limit,
            before=before,
            after=after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTestPeriods",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_uptime_test_periods_with_http_info(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of uptime check periods to return per page")] = None,
        before: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only check periods created before this UNIX timestamp will be returned")] = None,
        after: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only check periods created after this UNIX timestamp will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UptimeTestPeriods]:
        """Get all uptime check periods

        Returns a list of uptime check periods for a given id, detailing the creation time of the period, when it ended and the duration.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param limit: The number of uptime check periods to return per page
        :type limit: int
        :param before: Only check periods created before this UNIX timestamp will be returned
        :type before: int
        :param after: Only check periods created after this UNIX timestamp will be returned
        :type after: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_uptime_test_periods_serialize(
            test_id=test_id,
            limit=limit,
            before=before,
            after=after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTestPeriods",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_uptime_test_periods_without_preload_content(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of uptime check periods to return per page")] = None,
        before: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only check periods created before this UNIX timestamp will be returned")] = None,
        after: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only check periods created after this UNIX timestamp will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all uptime check periods

        Returns a list of uptime check periods for a given id, detailing the creation time of the period, when it ended and the duration.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param limit: The number of uptime check periods to return per page
        :type limit: int
        :param before: Only check periods created before this UNIX timestamp will be returned
        :type before: int
        :param after: Only check periods created after this UNIX timestamp will be returned
        :type after: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_uptime_test_periods_serialize(
            test_id=test_id,
            limit=limit,
            before=before,
            after=after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTestPeriods",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_uptime_test_periods_serialize(
        self,
        test_id,
        limit,
        before,
        after,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if test_id is not None:
            _path_params['test_id'] = test_id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/uptime/{test_id}/periods',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_uptime_tests(
        self,
        status: Annotated[Optional[StrictStr], Field(description="Uptime check status")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Page of results")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of uptime checks to return per page")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Comma separated list of tags assocaited with a check")] = None,
        matchany: Annotated[Optional[StrictBool], Field(description="Include uptime checks in response that match any specified tag or all tags. This parameter does not take a value. The absence of this paratemer equates to `false` whilst the presence of thie paramerter equates to `true`.")] = None,
        nouptime: Annotated[Optional[StrictBool], Field(description="Do not calculate uptime percentages for results. This parameter does not take a value. The absence of this paratemer equates to `false` whilst the presence of thie paramerter equates to `true`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UptimeTests:
        """Get all uptime checks

        Returns a list of uptime checks for an account.

        :param status: Uptime check status
        :type status: str
        :param page: Page of results
        :type page: int
        :param limit: The number of uptime checks to return per page
        :type limit: int
        :param tags: Comma separated list of tags assocaited with a check
        :type tags: str
        :param matchany: Include uptime checks in response that match any specified tag or all tags. This parameter does not take a value. The absence of this paratemer equates to `false` whilst the presence of thie paramerter equates to `true`.
        :type matchany: bool
        :param nouptime: Do not calculate uptime percentages for results. This parameter does not take a value. The absence of this paratemer equates to `false` whilst the presence of thie paramerter equates to `true`.
        :type nouptime: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_uptime_tests_serialize(
            status=status,
            page=page,
            limit=limit,
            tags=tags,
            matchany=matchany,
            nouptime=nouptime,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTests",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_uptime_tests_with_http_info(
        self,
        status: Annotated[Optional[StrictStr], Field(description="Uptime check status")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Page of results")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of uptime checks to return per page")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Comma separated list of tags assocaited with a check")] = None,
        matchany: Annotated[Optional[StrictBool], Field(description="Include uptime checks in response that match any specified tag or all tags. This parameter does not take a value. The absence of this paratemer equates to `false` whilst the presence of thie paramerter equates to `true`.")] = None,
        nouptime: Annotated[Optional[StrictBool], Field(description="Do not calculate uptime percentages for results. This parameter does not take a value. The absence of this paratemer equates to `false` whilst the presence of thie paramerter equates to `true`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UptimeTests]:
        """Get all uptime checks

        Returns a list of uptime checks for an account.

        :param status: Uptime check status
        :type status: str
        :param page: Page of results
        :type page: int
        :param limit: The number of uptime checks to return per page
        :type limit: int
        :param tags: Comma separated list of tags assocaited with a check
        :type tags: str
        :param matchany: Include uptime checks in response that match any specified tag or all tags. This parameter does not take a value. The absence of this paratemer equates to `false` whilst the presence of thie paramerter equates to `true`.
        :type matchany: bool
        :param nouptime: Do not calculate uptime percentages for results. This parameter does not take a value. The absence of this paratemer equates to `false` whilst the presence of thie paramerter equates to `true`.
        :type nouptime: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_uptime_tests_serialize(
            status=status,
            page=page,
            limit=limit,
            tags=tags,
            matchany=matchany,
            nouptime=nouptime,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTests",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_uptime_tests_without_preload_content(
        self,
        status: Annotated[Optional[StrictStr], Field(description="Uptime check status")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Page of results")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of uptime checks to return per page")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Comma separated list of tags assocaited with a check")] = None,
        matchany: Annotated[Optional[StrictBool], Field(description="Include uptime checks in response that match any specified tag or all tags. This parameter does not take a value. The absence of this paratemer equates to `false` whilst the presence of thie paramerter equates to `true`.")] = None,
        nouptime: Annotated[Optional[StrictBool], Field(description="Do not calculate uptime percentages for results. This parameter does not take a value. The absence of this paratemer equates to `false` whilst the presence of thie paramerter equates to `true`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all uptime checks

        Returns a list of uptime checks for an account.

        :param status: Uptime check status
        :type status: str
        :param page: Page of results
        :type page: int
        :param limit: The number of uptime checks to return per page
        :type limit: int
        :param tags: Comma separated list of tags assocaited with a check
        :type tags: str
        :param matchany: Include uptime checks in response that match any specified tag or all tags. This parameter does not take a value. The absence of this paratemer equates to `false` whilst the presence of thie paramerter equates to `true`.
        :type matchany: bool
        :param nouptime: Do not calculate uptime percentages for results. This parameter does not take a value. The absence of this paratemer equates to `false` whilst the presence of thie paramerter equates to `true`.
        :type nouptime: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_uptime_tests_serialize(
            status=status,
            page=page,
            limit=limit,
            tags=tags,
            matchany=matchany,
            nouptime=nouptime,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UptimeTests",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_uptime_tests_serialize(
        self,
        status,
        page,
        limit,
        tags,
        matchany,
        nouptime,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if status is not None:
            
            _query_params.append(('status', status))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if matchany is not None:
            
            _query_params.append(('matchany', matchany))
            
        if nouptime is not None:
            
            _query_params.append(('nouptime', nouptime))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/uptime',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_uptime_test(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        name: Annotated[Optional[StrictStr], Field(description="Name of the check")] = None,
        website_url: Annotated[Optional[StrictStr], Field(description="URL or IP address of the server under test")] = None,
        check_rate: Optional[UptimeTestCheckRate] = None,
        basic_username: Annotated[Optional[StrictStr], Field(description="Basic authentication username")] = None,
        basic_password: Annotated[Optional[StrictStr], Field(description="Basic authentication password")] = None,
        confirmation: Annotated[Optional[Annotated[int, Field(le=3, strict=True, ge=0)]], Field(description="Number of confirmation servers to confirm downtime before an alert is triggered")] = None,
        contact_groups: Annotated[Optional[List[StrictStr]], Field(description="List of contact group IDs")] = None,
        custom_header: Annotated[Optional[StrictStr], Field(description="JSON object. Represents headers to be sent when making requests")] = None,
        do_not_find: Annotated[Optional[StrictBool], Field(description="Whether to consider the check as down if the content is present within the response")] = None,
        dns_ips: Annotated[Optional[List[StrictStr]], Field(description="List of IP addresses to compare against returned DNS records")] = None,
        dns_server: Annotated[Optional[StrictStr], Field(description="FQDN or IP address of the nameserver to query")] = None,
        enable_ssl_alert: Annotated[Optional[StrictBool], Field(description="Whether to send an alert if the SSL certificate is soon to expire")] = None,
        final_endpoint: Annotated[Optional[StrictStr], Field(description="Specify where the redirect chain should end")] = None,
        find_string: Annotated[Optional[StrictStr], Field(description="String to look for within the response. Considered down if not found")] = None,
        follow_redirects: Annotated[Optional[StrictBool], Field(description="Whether to follow redirects when testing. Disabled by default")] = None,
        host: Annotated[Optional[StrictStr], Field(description="Name of the hosting provider")] = None,
        include_header: Annotated[Optional[StrictBool], Field(description="Include header content in string match search")] = None,
        paused: Annotated[Optional[StrictBool], Field(description="Whether the check should be run")] = None,
        port: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Destination port for TCP checks")] = None,
        post_body: Annotated[Optional[StrictStr], Field(description="JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb")] = None,
        post_raw: Annotated[Optional[StrictStr], Field(description="Raw HTTP POST string to send to the server")] = None,
        regions: Annotated[Optional[List[StrictStr]], Field(description="List of regions on which to run checks. The values required for this parameter can be retrieved from the `GET /v1/uptime-locations` endpoint.")] = None,
        status_codes_csv: Annotated[Optional[StrictStr], Field(description="Comma separated list of status codes that trigger an alert")] = None,
        tags: Annotated[Optional[List[StrictStr]], Field(description="List of tags")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(le=75, strict=True, ge=5)]], Field(description="The number of seconds to wait to receive the first byte")] = None,
        trigger_rate: Annotated[Optional[Annotated[int, Field(le=60, strict=True, ge=0)]], Field(description="The number of minutes to wait before sending an alert")] = None,
        use_jar: Annotated[Optional[StrictBool], Field(description="Whether to enable cookie storage")] = None,
        user_agent: Annotated[Optional[StrictStr], Field(description="Custom user agent string set when testing")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Update an uptime check

        Updates an uptime check with the given parameters.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param name: Name of the check
        :type name: str
        :param website_url: URL or IP address of the server under test
        :type website_url: str
        :param check_rate:
        :type check_rate: UptimeTestCheckRate
        :param basic_username: Basic authentication username
        :type basic_username: str
        :param basic_password: Basic authentication password
        :type basic_password: str
        :param confirmation: Number of confirmation servers to confirm downtime before an alert is triggered
        :type confirmation: int
        :param contact_groups: List of contact group IDs
        :type contact_groups: List[str]
        :param custom_header: JSON object. Represents headers to be sent when making requests
        :type custom_header: str
        :param do_not_find: Whether to consider the check as down if the content is present within the response
        :type do_not_find: bool
        :param dns_ips: List of IP addresses to compare against returned DNS records
        :type dns_ips: List[str]
        :param dns_server: FQDN or IP address of the nameserver to query
        :type dns_server: str
        :param enable_ssl_alert: Whether to send an alert if the SSL certificate is soon to expire
        :type enable_ssl_alert: bool
        :param final_endpoint: Specify where the redirect chain should end
        :type final_endpoint: str
        :param find_string: String to look for within the response. Considered down if not found
        :type find_string: str
        :param follow_redirects: Whether to follow redirects when testing. Disabled by default
        :type follow_redirects: bool
        :param host: Name of the hosting provider
        :type host: str
        :param include_header: Include header content in string match search
        :type include_header: bool
        :param paused: Whether the check should be run
        :type paused: bool
        :param port: Destination port for TCP checks
        :type port: int
        :param post_body: JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb
        :type post_body: str
        :param post_raw: Raw HTTP POST string to send to the server
        :type post_raw: str
        :param regions: List of regions on which to run checks. The values required for this parameter can be retrieved from the `GET /v1/uptime-locations` endpoint.
        :type regions: List[str]
        :param status_codes_csv: Comma separated list of status codes that trigger an alert
        :type status_codes_csv: str
        :param tags: List of tags
        :type tags: List[str]
        :param timeout: The number of seconds to wait to receive the first byte
        :type timeout: int
        :param trigger_rate: The number of minutes to wait before sending an alert
        :type trigger_rate: int
        :param use_jar: Whether to enable cookie storage
        :type use_jar: bool
        :param user_agent: Custom user agent string set when testing
        :type user_agent: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_uptime_test_serialize(
            test_id=test_id,
            name=name,
            website_url=website_url,
            check_rate=check_rate,
            basic_username=basic_username,
            basic_password=basic_password,
            confirmation=confirmation,
            contact_groups=contact_groups,
            custom_header=custom_header,
            do_not_find=do_not_find,
            dns_ips=dns_ips,
            dns_server=dns_server,
            enable_ssl_alert=enable_ssl_alert,
            final_endpoint=final_endpoint,
            find_string=find_string,
            follow_redirects=follow_redirects,
            host=host,
            include_header=include_header,
            paused=paused,
            port=port,
            post_body=post_body,
            post_raw=post_raw,
            regions=regions,
            status_codes_csv=status_codes_csv,
            tags=tags,
            timeout=timeout,
            trigger_rate=trigger_rate,
            use_jar=use_jar,
            user_agent=user_agent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_uptime_test_with_http_info(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        name: Annotated[Optional[StrictStr], Field(description="Name of the check")] = None,
        website_url: Annotated[Optional[StrictStr], Field(description="URL or IP address of the server under test")] = None,
        check_rate: Optional[UptimeTestCheckRate] = None,
        basic_username: Annotated[Optional[StrictStr], Field(description="Basic authentication username")] = None,
        basic_password: Annotated[Optional[StrictStr], Field(description="Basic authentication password")] = None,
        confirmation: Annotated[Optional[Annotated[int, Field(le=3, strict=True, ge=0)]], Field(description="Number of confirmation servers to confirm downtime before an alert is triggered")] = None,
        contact_groups: Annotated[Optional[List[StrictStr]], Field(description="List of contact group IDs")] = None,
        custom_header: Annotated[Optional[StrictStr], Field(description="JSON object. Represents headers to be sent when making requests")] = None,
        do_not_find: Annotated[Optional[StrictBool], Field(description="Whether to consider the check as down if the content is present within the response")] = None,
        dns_ips: Annotated[Optional[List[StrictStr]], Field(description="List of IP addresses to compare against returned DNS records")] = None,
        dns_server: Annotated[Optional[StrictStr], Field(description="FQDN or IP address of the nameserver to query")] = None,
        enable_ssl_alert: Annotated[Optional[StrictBool], Field(description="Whether to send an alert if the SSL certificate is soon to expire")] = None,
        final_endpoint: Annotated[Optional[StrictStr], Field(description="Specify where the redirect chain should end")] = None,
        find_string: Annotated[Optional[StrictStr], Field(description="String to look for within the response. Considered down if not found")] = None,
        follow_redirects: Annotated[Optional[StrictBool], Field(description="Whether to follow redirects when testing. Disabled by default")] = None,
        host: Annotated[Optional[StrictStr], Field(description="Name of the hosting provider")] = None,
        include_header: Annotated[Optional[StrictBool], Field(description="Include header content in string match search")] = None,
        paused: Annotated[Optional[StrictBool], Field(description="Whether the check should be run")] = None,
        port: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Destination port for TCP checks")] = None,
        post_body: Annotated[Optional[StrictStr], Field(description="JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb")] = None,
        post_raw: Annotated[Optional[StrictStr], Field(description="Raw HTTP POST string to send to the server")] = None,
        regions: Annotated[Optional[List[StrictStr]], Field(description="List of regions on which to run checks. The values required for this parameter can be retrieved from the `GET /v1/uptime-locations` endpoint.")] = None,
        status_codes_csv: Annotated[Optional[StrictStr], Field(description="Comma separated list of status codes that trigger an alert")] = None,
        tags: Annotated[Optional[List[StrictStr]], Field(description="List of tags")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(le=75, strict=True, ge=5)]], Field(description="The number of seconds to wait to receive the first byte")] = None,
        trigger_rate: Annotated[Optional[Annotated[int, Field(le=60, strict=True, ge=0)]], Field(description="The number of minutes to wait before sending an alert")] = None,
        use_jar: Annotated[Optional[StrictBool], Field(description="Whether to enable cookie storage")] = None,
        user_agent: Annotated[Optional[StrictStr], Field(description="Custom user agent string set when testing")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Update an uptime check

        Updates an uptime check with the given parameters.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param name: Name of the check
        :type name: str
        :param website_url: URL or IP address of the server under test
        :type website_url: str
        :param check_rate:
        :type check_rate: UptimeTestCheckRate
        :param basic_username: Basic authentication username
        :type basic_username: str
        :param basic_password: Basic authentication password
        :type basic_password: str
        :param confirmation: Number of confirmation servers to confirm downtime before an alert is triggered
        :type confirmation: int
        :param contact_groups: List of contact group IDs
        :type contact_groups: List[str]
        :param custom_header: JSON object. Represents headers to be sent when making requests
        :type custom_header: str
        :param do_not_find: Whether to consider the check as down if the content is present within the response
        :type do_not_find: bool
        :param dns_ips: List of IP addresses to compare against returned DNS records
        :type dns_ips: List[str]
        :param dns_server: FQDN or IP address of the nameserver to query
        :type dns_server: str
        :param enable_ssl_alert: Whether to send an alert if the SSL certificate is soon to expire
        :type enable_ssl_alert: bool
        :param final_endpoint: Specify where the redirect chain should end
        :type final_endpoint: str
        :param find_string: String to look for within the response. Considered down if not found
        :type find_string: str
        :param follow_redirects: Whether to follow redirects when testing. Disabled by default
        :type follow_redirects: bool
        :param host: Name of the hosting provider
        :type host: str
        :param include_header: Include header content in string match search
        :type include_header: bool
        :param paused: Whether the check should be run
        :type paused: bool
        :param port: Destination port for TCP checks
        :type port: int
        :param post_body: JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb
        :type post_body: str
        :param post_raw: Raw HTTP POST string to send to the server
        :type post_raw: str
        :param regions: List of regions on which to run checks. The values required for this parameter can be retrieved from the `GET /v1/uptime-locations` endpoint.
        :type regions: List[str]
        :param status_codes_csv: Comma separated list of status codes that trigger an alert
        :type status_codes_csv: str
        :param tags: List of tags
        :type tags: List[str]
        :param timeout: The number of seconds to wait to receive the first byte
        :type timeout: int
        :param trigger_rate: The number of minutes to wait before sending an alert
        :type trigger_rate: int
        :param use_jar: Whether to enable cookie storage
        :type use_jar: bool
        :param user_agent: Custom user agent string set when testing
        :type user_agent: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_uptime_test_serialize(
            test_id=test_id,
            name=name,
            website_url=website_url,
            check_rate=check_rate,
            basic_username=basic_username,
            basic_password=basic_password,
            confirmation=confirmation,
            contact_groups=contact_groups,
            custom_header=custom_header,
            do_not_find=do_not_find,
            dns_ips=dns_ips,
            dns_server=dns_server,
            enable_ssl_alert=enable_ssl_alert,
            final_endpoint=final_endpoint,
            find_string=find_string,
            follow_redirects=follow_redirects,
            host=host,
            include_header=include_header,
            paused=paused,
            port=port,
            post_body=post_body,
            post_raw=post_raw,
            regions=regions,
            status_codes_csv=status_codes_csv,
            tags=tags,
            timeout=timeout,
            trigger_rate=trigger_rate,
            use_jar=use_jar,
            user_agent=user_agent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_uptime_test_without_preload_content(
        self,
        test_id: Annotated[StrictStr, Field(description="Uptime check ID")],
        name: Annotated[Optional[StrictStr], Field(description="Name of the check")] = None,
        website_url: Annotated[Optional[StrictStr], Field(description="URL or IP address of the server under test")] = None,
        check_rate: Optional[UptimeTestCheckRate] = None,
        basic_username: Annotated[Optional[StrictStr], Field(description="Basic authentication username")] = None,
        basic_password: Annotated[Optional[StrictStr], Field(description="Basic authentication password")] = None,
        confirmation: Annotated[Optional[Annotated[int, Field(le=3, strict=True, ge=0)]], Field(description="Number of confirmation servers to confirm downtime before an alert is triggered")] = None,
        contact_groups: Annotated[Optional[List[StrictStr]], Field(description="List of contact group IDs")] = None,
        custom_header: Annotated[Optional[StrictStr], Field(description="JSON object. Represents headers to be sent when making requests")] = None,
        do_not_find: Annotated[Optional[StrictBool], Field(description="Whether to consider the check as down if the content is present within the response")] = None,
        dns_ips: Annotated[Optional[List[StrictStr]], Field(description="List of IP addresses to compare against returned DNS records")] = None,
        dns_server: Annotated[Optional[StrictStr], Field(description="FQDN or IP address of the nameserver to query")] = None,
        enable_ssl_alert: Annotated[Optional[StrictBool], Field(description="Whether to send an alert if the SSL certificate is soon to expire")] = None,
        final_endpoint: Annotated[Optional[StrictStr], Field(description="Specify where the redirect chain should end")] = None,
        find_string: Annotated[Optional[StrictStr], Field(description="String to look for within the response. Considered down if not found")] = None,
        follow_redirects: Annotated[Optional[StrictBool], Field(description="Whether to follow redirects when testing. Disabled by default")] = None,
        host: Annotated[Optional[StrictStr], Field(description="Name of the hosting provider")] = None,
        include_header: Annotated[Optional[StrictBool], Field(description="Include header content in string match search")] = None,
        paused: Annotated[Optional[StrictBool], Field(description="Whether the check should be run")] = None,
        port: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Destination port for TCP checks")] = None,
        post_body: Annotated[Optional[StrictStr], Field(description="JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb")] = None,
        post_raw: Annotated[Optional[StrictStr], Field(description="Raw HTTP POST string to send to the server")] = None,
        regions: Annotated[Optional[List[StrictStr]], Field(description="List of regions on which to run checks. The values required for this parameter can be retrieved from the `GET /v1/uptime-locations` endpoint.")] = None,
        status_codes_csv: Annotated[Optional[StrictStr], Field(description="Comma separated list of status codes that trigger an alert")] = None,
        tags: Annotated[Optional[List[StrictStr]], Field(description="List of tags")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(le=75, strict=True, ge=5)]], Field(description="The number of seconds to wait to receive the first byte")] = None,
        trigger_rate: Annotated[Optional[Annotated[int, Field(le=60, strict=True, ge=0)]], Field(description="The number of minutes to wait before sending an alert")] = None,
        use_jar: Annotated[Optional[StrictBool], Field(description="Whether to enable cookie storage")] = None,
        user_agent: Annotated[Optional[StrictStr], Field(description="Custom user agent string set when testing")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update an uptime check

        Updates an uptime check with the given parameters.

        :param test_id: Uptime check ID (required)
        :type test_id: str
        :param name: Name of the check
        :type name: str
        :param website_url: URL or IP address of the server under test
        :type website_url: str
        :param check_rate:
        :type check_rate: UptimeTestCheckRate
        :param basic_username: Basic authentication username
        :type basic_username: str
        :param basic_password: Basic authentication password
        :type basic_password: str
        :param confirmation: Number of confirmation servers to confirm downtime before an alert is triggered
        :type confirmation: int
        :param contact_groups: List of contact group IDs
        :type contact_groups: List[str]
        :param custom_header: JSON object. Represents headers to be sent when making requests
        :type custom_header: str
        :param do_not_find: Whether to consider the check as down if the content is present within the response
        :type do_not_find: bool
        :param dns_ips: List of IP addresses to compare against returned DNS records
        :type dns_ips: List[str]
        :param dns_server: FQDN or IP address of the nameserver to query
        :type dns_server: str
        :param enable_ssl_alert: Whether to send an alert if the SSL certificate is soon to expire
        :type enable_ssl_alert: bool
        :param final_endpoint: Specify where the redirect chain should end
        :type final_endpoint: str
        :param find_string: String to look for within the response. Considered down if not found
        :type find_string: str
        :param follow_redirects: Whether to follow redirects when testing. Disabled by default
        :type follow_redirects: bool
        :param host: Name of the hosting provider
        :type host: str
        :param include_header: Include header content in string match search
        :type include_header: bool
        :param paused: Whether the check should be run
        :type paused: bool
        :param port: Destination port for TCP checks
        :type port: int
        :param post_body: JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb
        :type post_body: str
        :param post_raw: Raw HTTP POST string to send to the server
        :type post_raw: str
        :param regions: List of regions on which to run checks. The values required for this parameter can be retrieved from the `GET /v1/uptime-locations` endpoint.
        :type regions: List[str]
        :param status_codes_csv: Comma separated list of status codes that trigger an alert
        :type status_codes_csv: str
        :param tags: List of tags
        :type tags: List[str]
        :param timeout: The number of seconds to wait to receive the first byte
        :type timeout: int
        :param trigger_rate: The number of minutes to wait before sending an alert
        :type trigger_rate: int
        :param use_jar: Whether to enable cookie storage
        :type use_jar: bool
        :param user_agent: Custom user agent string set when testing
        :type user_agent: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_uptime_test_serialize(
            test_id=test_id,
            name=name,
            website_url=website_url,
            check_rate=check_rate,
            basic_username=basic_username,
            basic_password=basic_password,
            confirmation=confirmation,
            contact_groups=contact_groups,
            custom_header=custom_header,
            do_not_find=do_not_find,
            dns_ips=dns_ips,
            dns_server=dns_server,
            enable_ssl_alert=enable_ssl_alert,
            final_endpoint=final_endpoint,
            find_string=find_string,
            follow_redirects=follow_redirects,
            host=host,
            include_header=include_header,
            paused=paused,
            port=port,
            post_body=post_body,
            post_raw=post_raw,
            regions=regions,
            status_codes_csv=status_codes_csv,
            tags=tags,
            timeout=timeout,
            trigger_rate=trigger_rate,
            use_jar=use_jar,
            user_agent=user_agent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_uptime_test_serialize(
        self,
        test_id,
        name,
        website_url,
        check_rate,
        basic_username,
        basic_password,
        confirmation,
        contact_groups,
        custom_header,
        do_not_find,
        dns_ips,
        dns_server,
        enable_ssl_alert,
        final_endpoint,
        find_string,
        follow_redirects,
        host,
        include_header,
        paused,
        port,
        post_body,
        post_raw,
        regions,
        status_codes_csv,
        tags,
        timeout,
        trigger_rate,
        use_jar,
        user_agent,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'contact_groups': 'csv',
            'dns_ips': 'csv',
            'regions': 'csv',
            'tags': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if test_id is not None:
            _path_params['test_id'] = test_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if name is not None:
            _form_params.append(('name', name))
        if website_url is not None:
            _form_params.append(('website_url', website_url))
        if check_rate is not None:
            _form_params.append(('check_rate', check_rate))
        if basic_username is not None:
            _form_params.append(('basic_username', basic_username))
        if basic_password is not None:
            _form_params.append(('basic_password', basic_password))
        if confirmation is not None:
            _form_params.append(('confirmation', confirmation))
        if contact_groups is not None:
            _form_params.append(('contact_groups', contact_groups))
        if custom_header is not None:
            _form_params.append(('custom_header', custom_header))
        if do_not_find is not None:
            _form_params.append(('do_not_find', do_not_find))
        if dns_ips is not None:
            _form_params.append(('dns_ips', dns_ips))
        if dns_server is not None:
            _form_params.append(('dns_server', dns_server))
        if enable_ssl_alert is not None:
            _form_params.append(('enable_ssl_alert', enable_ssl_alert))
        if final_endpoint is not None:
            _form_params.append(('final_endpoint', final_endpoint))
        if find_string is not None:
            _form_params.append(('find_string', find_string))
        if follow_redirects is not None:
            _form_params.append(('follow_redirects', follow_redirects))
        if host is not None:
            _form_params.append(('host', host))
        if include_header is not None:
            _form_params.append(('include_header', include_header))
        if paused is not None:
            _form_params.append(('paused', paused))
        if port is not None:
            _form_params.append(('port', port))
        if post_body is not None:
            _form_params.append(('post_body', post_body))
        if post_raw is not None:
            _form_params.append(('post_raw', post_raw))
        if regions is not None:
            _form_params.append(('regions', regions))
        if status_codes_csv is not None:
            _form_params.append(('status_codes_csv', status_codes_csv))
        if tags is not None:
            _form_params.append(('tags', tags))
        if timeout is not None:
            _form_params.append(('timeout', timeout))
        if trigger_rate is not None:
            _form_params.append(('trigger_rate', trigger_rate))
        if use_jar is not None:
            _form_params.append(('use_jar', use_jar))
        if user_agent is not None:
            _form_params.append(('user_agent', user_agent))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/uptime/{test_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


